\documentclass[11pt]{article}
\author{Arhan Rupani (1008796812) and Joseph Duraisingh ()}
% This is the local copy of the csc373 pset1
% Finishing this assignment plus learning llatex from the book "not so short introduction to latex"
% some comments are mine and some are by the prof

%% preamble
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{fullpage}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{xifthen}%
\usepackage[hidelinks,colorlinks]{hyperref}
\setlength\parindent{0pt}
\usepackage{tikz}
\usetikzlibrary{positioning}

% Counter for Questions
\newcounter{question}

% Question
\newcommand{\question}[2]{%
	\stepcounter{question}
	\vspace{.25in} \textbf{Q\arabic{question} 
		\ifthenelse{\isempty{#1}}%
		{}% if no points
		{[#1 Points]\ }% if #1 is not empty
		#2}\vspace{0.10in}
}

% Subquestion
\newcommand{\qpart}[2]{%
	\vspace{.10in} \textbf{(#1)}
	\ifthenelse{\isempty{#2}}%
	{}% if no points
	{[#2 Points]}% if #1 is not empty
}

\newcommand{\references}{\vspace{.25in}\textbf{References}\vspace{.10in}}

% Solution to question
\newcommand{\solution}{\vspace{.25in}\textbf{Solution}\vspace{.10in}}

% Solution to subquestion
\newcommand{\solpart}[1] {\vspace{.10in}\textbf{(#1)}}

% Should the solutions be displayed?
\newif\ifsolutions
\solutionstrue

% Should the marking scheme be displayed?
\newif\ifmarkingscheme
\markingschemefalse

% Math commands
\newcommand{\set}[1]{\{#1\}}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\title{CSC373 Assignment 1 solutions}
\date{Due Monday, 2026 Jan 26, 23:59 p.m. EST}

\begin{document}
\maketitle

\question{20}{Divide and Conquer}

A binary tree $T$ is complete if every internal node has two children and every leaf has the same depth. A subtree of a binary tree is any connected subgraph. 

\qpart{a}{10} Suppose we want to find the largest complete binary tree that is a subtree of a given binary tree $T$. Design a a divide-and-conquer algorithm for computing this, returning the complete tree's root node $t$ and its depth $d.$

\qpart{b}{10} Justify the correctness and runtime of the algorithm given in part (a).

\question{20}{Divide and Conquer}

Imagine we are given $n$ distinct points $P = \{p_1, \dots, p_n\}$ all lying on the line $y = 0$ and another $n$ distinct points $Q = \{q_1, \dots, q_n\}$ all lying on the line $y = 1$. Suppose we connect $p_i$ to $q_i$ using a line for each $1 \leq i \leq n.$ 

\qpart{a}{10} Design a divide and conquer algorithm to determine how many pairs of lines intersect. The algorithm should run in time $O(n \log n)$.

\qpart{b}{10} Briefly justify why the algorithm given in the previous part works. 



\question{20}{Greedy Algorithms}

You are to organize $n$ events where each takes one unit of time. Event $i$ will provide a profit
of $g_i$ dollars ($g_i > 0$) if started at or before time $t_i$ where $t_i$ is an arbitrary real number.
(Note: If an event is not started by $t_i$ then there is no benefit in scheduling it at all.
All events can start as early as time $0$.)

\qpart{a}{7}
Design an efficient algorithm to find an optimal solution
for this problem. Specify the data structure and the operations that you use in your algorithm.

\qpart{b}{3} Analyze its time complexity.

\qpart{c}{10} Prove that the algorithm is correct. 

\vspace{10px}

\textbf{Answer:}\\

$E$ is a linked list of events, where each event $E_i$ is a node which contains the given info $t_i$ and $g_i$.\\
In the algorithm we use a heuristic $h_i$ as defined below, which can be interpreted as maximum number of events that can be scheduled before the $i^{th}$ event to still get a profit by scheduling the $i^{th}$ event.\\
$scheduleList$ is a list of size $n$ which starts from index 0 and can be indexed in constant time.

\begin{algorithm}
\caption{GreedyEventSelect}\label{greedy-events}
\begin{algorithmic}[1]
\Procedure{GreedyEventSelect}{$E$}\Comment{E is the list of events } 
    \For{each event $e$ in $E$}
        \State initialize $e.h$ 
		\State $e.h \gets min(\lceil {e.t - 1} \rceil, n)$
    \EndFor
	\State \textbf{Sort} the events in $E$ in decreasing order based on $g_i$\Comment{O(nlogn)}
	
	\State Initilize $scheduleList[n]$\Comment{size n}
	%\State Initilize $scheduleList_{min}$ as none \Comment{Attribute of the list which stores the least profitable job in the so far}
	\For{each event $e$ in $E$}\Comment{$O(n^2)$} 
	\If{$e.h < 0$}\Comment{skip events with deadline $\leq 0$}
        \State next 
	\Else
		\State Index into $scheduleList[e.h]$ and check 
		\State \textbf{if} the position is empty then add the event 
		\State \textbf{else} start looping backwards from index $e.h$ to $0$ and add it in the first empty space you find in $scheduleList$\Comment{O(n)}
		\State \textbf{else} if no position is empty then dont schedule the event

	\EndIf	
	\EndFor
	
    \State \textbf{return} $scheduleList$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Worst case run time of our algorithm is $O(n^2)$. The sorting part takes $O(nlogn)$ but then while checking if an event fits in the optimal schedule or not requires it to be inserted in an empty position if available, and finding this empty position requires another backwards forloop. In the worst case this backwards forloop takes time $O(n)$, and doingf this for all the events means the worst case run time becomes $O(n^2)$. However, I believe this overhead can be worked around by using some kind of data structure which can keep track of the availability, if there is, and a pointer to the empty position.\\

\textbf{Proof:} We will prove the optimality by induction,
\begin{itemize}
	\item Let $S_j$ be a subset of events that are scheduled by our greedy algorithm after considering the $j^{th}$ most profitable job
	\begin{itemize}
		\item Define $S_0 = \emptyset$
	\end{itemize}
	\item We call $S_j$ promising if $\exists T \subseteq \{j+1, ..., n\}$ such that some optimal solution set extends it, i.e. $O_j = S_j \cup T$\\
	We want to prove that $\forall t \in \{1, ..., n\}, S_t$ is promising.
	\item \textbf{Base case:} $S_0$ is promising as any optimal set extends it.
	\item \textbf{Inductive step:} Assume some optimal set $O_j$ extends the subset $S_j$ selected by our algorithm after considering the $j_{th}$ most profitable event [IH]\\
	We will show that there exists a set $O_{j+1}$ which extends the set $S_{j+1}$ chosen by our algorithm after considering the $j + 1^{st}$ most profitable event.
	\item For $j + 1^{st}$ event, there are only two possible options either our algorithm adds it or doesnot add it to the set $S_{j+1}$
	\item Say our geedy algorithm does not add $j + 1^{st}$ event to the set, that could be when
	\begin{itemize}
		\item $t_{j+1}$ is negative in which case if the optimal schedule has that job or not, it does not affect the total profit, so $S_{j+1}$ is still optimal [IH]
		\item $j + 1^{st}$ cannot be scheduled because there are already greater than $h_{j+1}$ jobs scheduled all with greater profit (due to the sort in algorithm) therefore optimal schedule will not have it because if it does then that is suboptimal as to accommodate, the optimal set has to replace one of the greater profit jobs with $t_{j+1}$, which makes total profit of $O_{j+1}$ less than that of $O_{j}$. Therefore, $S_{j+1}$ is still optimal [IH]
		\item Above are the only two cases when our algorithm does not schedule a job and we have shown that in both the cases $S_{j+1}$ remains optimal 
	\end{itemize} 
	\item Say our greedy algorithm does add the $j + 1^{st}$ event to the set which means that there are less than or equal to $h_{j+1}$ jobs scheduled so far and so hte optimal schedule has to also have this event, if it doesnot than its suboptimal for total profit (as because of the sort there are no greater profit jobs coming up). Therefore, $S_{j+1}$ remains optimal in this case as well.\qed
\end{itemize}


\question{20}{Greedy Algorithms}

You are the mayor of the town of Camelot and have recently built a circular street inside the town. Merchants are applying to build their shops on the street, with each submitting an arc $(a, b)$ with $0 \leq a, b \leq 360$ labelling the portion where they would like to build their shop. For example, examples of requests may be a 25 degree region between $(75, 100)$ or $(350, 15).$ As mayor of the town, you would like to approve as many merchants' requests as possible to boost your town's economy. However, merchants will only be satisfied if and only if their entire request can be satisfied, so not all requests can be satisfied if some of the arcs overlap.

\qpart{a}{7} Design an greedy algorithm to maximize the number of requests that can be satisfied.

\qpart{b}{3} Analyze the run time of the algorithm given in part (a).

\qpart{c}{5} Give an argument to show that your algorithm in part (a) is correct.

\qpart{d}{5} Show that the greedy algorithm in part (a) may not maximize the total {\bf length} of the arcs being picked, although it maximizes the total number of requests being satisfied.

\vspace{10px}

\textbf{Answer:} Below we will describe the idea of our algorithm along with some brief  justifications:\\

\textbf{GreedyCircularScheduling()}
\begin{enumerate}
	\item Find all requests where $a > b$ and put them in a list/set $C$ (all of these jobs have a thing in common which is that they are all conflicting with any one of the jobs, this conflict is at the point $a = 0, b = 0$)
	\item We consider one of these requests, say $r_i$, at a time and remove all the jobs which are conflicting with $r_i$. This means all the jobs in $C$ plus any other job which conflicts with this job $r_i$. The set of remaining jobs $R_i$ will be considered for further scheduling
	\begin{enumerate}
		\item Now readjust the coordinates of the circle where $0, 360$ falls at the $a$ of $r_i$, accordingly transform the coordinates $(a, b)$ of all the requests in $R_i$
		\item Now the problem just becomes a linear job scheduling problem (as discussed in class) with start and finish times as transformed $(a, b)$, therefore apply the greedy algorithm where we sort by finish times to maximize the number of requests.
		\item Store the maximum requests that can be accommodated in this iteration in a list $Max$ along with the corresponding order (store a pointer to an order object at each node)
	\end{enumerate}

	\item Repeat step 2 with all the requests in $C$ and once with removing all requests from $C$
	\item Loop through the list $Max$ and return the maximum number along with its associated order 
\end{enumerate}

\textbf{Runtime analysis:} 
\begin{itemize}
	\item Step 1 takes time $O(n)$, which is just comparing $a$ and $b$ of each job for all the jobs
	\item Step 2 also takes time $O(n)$, which is just checking if a job overlaps with a certain job, for all the jobs
	\item Step 2a also takes time $O(n)$ in the worst case, which involves readjusting the coordinates for all the jobs in $C$
	\item Step 2b takes time $O(nlogn)$ as it requires sorting to then implement greedy which is only $O(n)$
	\item Step 2c takes time $O(1)$
	\item Step 3 requires Steps 2, 2.a, 2.b, and 2.3 to be done $n$ times in the worst case, which now makes the running of this algorithm $n^2logn$
	\item Step 4 takes $O(n)$ time 
\end{itemize}
Therefore, overall the worst case running time of this algorithm is $O(n^2logn)$\\

\textbf{Argument for correctness}: For this proof we focus on a specific set of requests, that have $a > b$, which specifically make this a circular scheduling problem. Our algorithm heuristically transforms this circular scheduling problem into a linear scheduling problem. Therefore, here we will justify the optimality of this heuristic and then complete proof of optimality follows from the optimality proof of the greedy scheduling on the linear scheduling problem (done in class).\\

Consider some optimal solution $O$. Now consider all the requests that have $a > b$ in set $C$. The optimal schedule $O$ can either some request from $C$ or not have any request from $C$.
\begin{itemize}
	\item Consider the case where it has one request $r_i$ from $C$
	\begin{itemize}
		\item It can only have one request $r_i$ from $C$ because all the other requests in $C$ conflict with $r_i$. This is due to the nature of all the requests in $C$.
		\item Infact if $O$ has $r_i$ then it can not have any other requests that overlap with $r_i$, this means that if we cut the circle's circumference at the start time of $r_i$ and make it a straight line then upon scheduling of $r_i$ the rest of the problem becomes a linear job scheduling problem.
	\end{itemize}
	\item Consider the case where it does not have any request from $C$
	\begin{itemize}
		\item In our algorithm we first convert the circular scheduling problem to the linear scheduling problem, in step 3 we also consider the case where all of the requests from $C$ are removed
		\item Using the fact that the greedy algoritm for linear scheduling is optimal, we are guranteed that in this case our algorithm will return an optimal solution comparable to $O$ 
	\end{itemize}
\end{itemize}

We know that our algorithm is optimal for maximizing the total number of requests being satisfied (from the argument of optimality), however our algorithm does not always maximize the total {\bf length} of the arcs being picked. We will show this by giving an example.\\

Consider the following set of requests, \set{(20, 60), (160, 200), (300, 340), (0, 180), (180, 360)}. Now selecting the requests \set{(0, 180), (180, 360)} leads to the total length of arcs being maximized, however our algorithm will not select these as it picks greedy based on earliest finish time. Our algorithm will pick the requests \set{(20, 60), (160, 200), (300, 340)} based on the earliest finish time heuristic and therefore results in the number of selected requests being maximized. 


\vspace{\baselineskip}
\references \\
Please write down your references here, including any paper or online resources you consult.  In the event that you use generative AI, at any point in your work cite it here, provide the prompt used to generate the response.  Ensure that your own words are used for everything and if Generative AI is used then a higher standard of scrutiny will be applied to your work so be careful to explain every step in the resulting algorithm in your own words.  Failure to do so will be considered plagiarism.\\

No Gen. AI was used at any point in completing questions 3 and 4. The following online resource was consulted to gain insight in order to come up with a solution for question 4:
\begin{itemize}
	\item https://www.cse.iitd.ac.in/~amitk/SemI-2017/tut1.pdf
\end{itemize}
\end{document}

	\If{$len(scheduleList) \le h_i$}
			\State Add the job to the $scheduleList$			
		\ElsIf{$scheduleList_{min}.g_i < e.g_i$}
			\State Add the job to the $scheduleList$
			\State Loop through $scheduleList$ to determine the lowest profit job and store it in $scheduleList_{min}$ \Comment{This step results in our greedy algorithm being of O($n^2$)}
		\EndIf